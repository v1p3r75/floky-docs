{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-floky","title":"What is Floky ?","text":"<p>Floky is a MVC (Model-View-Controller) framework for developing web applications in PHP. It provides an organized structure for your code, powerful features, and flexibility to create robust and scalable web applications.</p>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>MVC architecture: Organize your code in a clean and modular way.</li> <li>Powerful Routing: Manage URLs flexibly to direct requests to the appropriate controllers.</li> <li>Database Management: Facilitate interaction with databases thanks to NexaORM (a powerful and easy to use flexible new generation ORM in hand).</li> <li>Security: Integrate security mechanisms to protect your application against common vulnerabilities.</li> <li>Flexible View: Use the BladeOne template engine to design rich and dynamic views.</li> <li>Dependency Container: Use a dependency container to manage your application's services efficiently.</li> <li>More Elegant Tests: Take advantage of Pest, an elegant testing framework for PHP, to write clean, readable and expressive tests for your application.</li> <li>Reusable Components: Take advantage of libraries and tools to accelerate development.</li> <li>Complete Documentation: A detailed guide to help you get started quickly.</li> </ul>"},{"location":"#why-floky","title":"Why Floky ?","text":"<p>The idea behind Floky is not to reinvent the wheel, but to provide a set of well-designed, easy-to-use tools for smaller projects. We sought to simplify development by avoiding unnecessary complexity, while still providing flexibility to create quality web applications. Floky was designed to meet a fundamental need: to allow developers to quickly start a project without having to spend weeks understanding how many tools work. We understand that sometimes you just need a lightweight and efficient tool to bring your ideas to life without being overwhelmed by a multitude of unnecessary features.</p> <p>Here's why Floky may be the perfect choice for your next project:</p> <ul> <li>Quick Start</li> </ul> <p>With Floky, you can quickly set up your app structure and start writing working code in no time. Our simple, modular architecture allows you to focus on the logic of your application without having to worry about complex configurations.</p> <ul> <li>Less Learning Curve</li> </ul> <p>Unlike many massive frameworks, Floky is designed to be intuitive. You don't need to spend hours understanding documentation or learning abstract concepts. Getting to grips with things like routes, middleware, and other key Floky concepts is a quick and seamless process.</p> <ul> <li>Lightweight and Adaptable</li> </ul> <p>Floky is a lightweight framework that doesn't overload your project with unnecessary features. It is ideal for smaller projects, providing you with the essential tools to create effective web applications.</p> <p>Whether your project is a small website, a simple web application, or a prototype, Floky can help you move forward quickly without sacrificing quality. It provides the flexibility you need to focus on what really matters: bringing your project to life.</p> <p>So why wait? Try Floky today and start developing your ideas without unnecessary hassle and complications.</p>"},{"location":"#installation","title":"Installation","text":"<ul> <li> <p>Make sure you have Composer installed on your system. If not, you can download and install it from the official website of Composer.</p> </li> <li> <p>Run the Composer command to create and install the application dependencies:</p> Bash<pre><code>composer create-project v1p3r75/floky\n</code></pre> </li> <li> <p>You will now have the most recent version of your framework and all dependencies correctly installed.</p> </li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>Development of Floky is currently underway, and we welcome any contribution from the community.</p> <p>The core development team currently includes the following contributors:</p> <ul> <li>Fortunatus KIDJE (v1p3r75) - Founder and lead developer</li> <li>Kabirou ALASSANE (BlakvGhost) - Associate developer</li> </ul> <p>We are excited to grow this project and add new features to meet the needs of the PHP developer community. Join us in this adventure and help make Floky an even lighter and more powerful tool for developing web applications in PHP.</p>"},{"location":"#licence","title":"Licence","text":"<p>This project is licensed under the MIT.</p>"},{"location":"cli/add-new-commands/","title":"Add Your Own Commands","text":""},{"location":"cli/cli-commands/","title":"Commands","text":""},{"location":"database/entities/","title":"Entities","text":""},{"location":"database/migrations/","title":"Migrations","text":""},{"location":"database/models/","title":"Models","text":""},{"location":"database/seeders/","title":"Seeders","text":""},{"location":"get-started/","title":"Introduction","text":""},{"location":"get-started/#what-is-floky","title":"What is Floky ?","text":"<p>Floky is a MVC (Model-View-Controller) framework for developing web applications in PHP. It provides an organized structure for your code, powerful features, and flexibility to create robust and scalable web applications.</p>"},{"location":"get-started/#main-features","title":"Main Features","text":"<ul> <li>MVC architecture: Organize your code in a clean and modular way.</li> <li>Powerful Routing: Manage URLs flexibly to direct requests to the appropriate controllers.</li> <li>Database Management: Facilitate interaction with databases thanks to NexaORM (a powerful and easy to use flexible new generation ORM in hand).</li> <li>Security: Integrate security mechanisms to protect your application against common vulnerabilities.</li> <li>Flexible View: Use the BladeOne template engine to design rich and dynamic views.</li> <li>Dependency Container: Use a dependency container to manage your application's services efficiently.</li> <li>More Elegant Tests: Take advantage of Pest, an elegant testing framework for PHP, to write clean, readable and expressive tests for your application.</li> <li>Reusable Components: Take advantage of libraries and tools to accelerate development.</li> <li>Complete Documentation: A detailed guide to help you get started quickly.</li> </ul>"},{"location":"get-started/#why-floky","title":"Why Floky ?","text":"<p>The idea behind Floky is not to reinvent the wheel, but to provide a set of well-designed, easy-to-use tools for smaller projects. We sought to simplify development by avoiding unnecessary complexity, while still providing flexibility to create quality web applications. Floky was designed to meet a fundamental need: to allow developers to quickly start a project without having to spend weeks understanding how many tools work. We understand that sometimes you just need a lightweight and efficient tool to bring your ideas to life without being overwhelmed by a multitude of unnecessary features.</p> <p>Here's why Floky may be the perfect choice for your next project:</p> <ul> <li>Quick Start</li> </ul> <p>With Floky, you can quickly set up your app structure and start writing working code in no time. Our simple, modular architecture allows you to focus on the logic of your application without having to worry about complex configurations.</p> <ul> <li>Less Learning Curve</li> </ul> <p>Unlike many massive frameworks, Floky is designed to be intuitive. You don't need to spend hours understanding documentation or learning abstract concepts. Getting to grips with things like routes, middleware, and other key Floky concepts is a quick and seamless process.</p> <ul> <li>Lightweight and Adaptable</li> </ul> <p>Floky is a lightweight framework that doesn't overload your project with unnecessary features. It is ideal for smaller projects, providing you with the essential tools to create effective web applications.</p> <p>Whether your project is a small website, a simple web application, or a prototype, Floky can help you move forward quickly without sacrificing quality. It provides the flexibility you need to focus on what really matters: bringing your project to life.</p> <p>So why wait? Try Floky today and start developing your ideas without unnecessary hassle and complications.</p>"},{"location":"get-started/#installation","title":"Installation","text":"<ul> <li> <p>Make sure you have Composer installed on your system. If not, you can download and install it from the official website of Composer.</p> </li> <li> <p>Run the Composer command to create and install the application dependencies:</p> Bash<pre><code>composer create-project v1p3r75/floky\n</code></pre> </li> <li> <p>You will now have the most recent version of your framework and all dependencies correctly installed.</p> </li> </ul>"},{"location":"get-started/#contributors","title":"Contributors","text":"<p>Development of Floky is currently underway, and we welcome any contribution from the community.</p> <p>The core development team currently includes the following contributors:</p> <ul> <li>Fortunatus KIDJE (v1p3r75) - Founder and lead developer</li> <li>Kabirou ALASSANE (BlakvGhost) - Associate developer</li> </ul> <p>We are excited to grow this project and add new features to meet the needs of the PHP developer community. Join us in this adventure and help make Floky an even lighter and more powerful tool for developing web applications in PHP.</p>"},{"location":"get-started/#licence","title":"Licence","text":"<p>This project is licensed under the MIT.</p>"},{"location":"get-started/configuration/","title":"Configuration","text":"<p>The configuration of your application is in the <code>.env</code> file (Rename the <code>.env.example</code> file to <code>.env</code>). Here you can define database settings, secret keys, and other configurations specific to your application.</p>"},{"location":"get-started/configuration/#project-structure","title":"Project Structure","text":"<ul> <li><code>public/</code>: The entry point of your application, the files accessible from the browser.</li> <li><code>src/</code>: The main directory of your source code.<ul> <li><code>app/</code>: Contains the controllers, entities, models, middleware, services, and other components of your application.</li> <li><code>config/</code>: Contains the configuration files of your application.</li> <li><code>database/</code>: Contains migration files, seeders, ...</li> <li><code>routes/</code>: The route definition files for your application.</li> <li><code>storage/</code>: Files generated by the application, such as logs, sessions, etc.</li> <li><code>views/</code>: Contains the template files for generating views.</li> <li>... (other directories and files specific to your project)</li> </ul> </li> <li><code>test/</code>: Contains the test files for the application.</li> </ul>"},{"location":"get-started/configuration/#how-to-launch-the-application","title":"How to Launch the Application","text":"<p>Once you have Floky installed, you are ready to launch your application. Follow these simple steps to start your project:</p>"},{"location":"get-started/configuration/#use-php-server","title":"Use PHP server","text":"<ol> <li> <p>Environment Configuration: Before launching your application, make sure you have correctly configured the environment. Make sure settings, such as database connection and other options specific to your project, are set correctly.</p> </li> <li> <p>Database Migrations: If your application uses a database, be sure to perform the necessary migrations to create the database tables and schemas. You can use specific commands provided by the framework to perform these migrations :</p> Prepare all migrations<pre><code>php floky make:migrations\n</code></pre> Run all migrations<pre><code>php floky run:migrations\n</code></pre> </li> <li> <p>Creating Routes: Configure your routes in the <code>src/routes/</code> directory. This is where you specify how URLs should be handled by your application. You can define controllers, actions and parameters for each route.</p> </li> <li> <p>Creating Controllers and Views: Develop controllers and views to manage different parts of your application. Controllers define the logic for handling requests, while views define the presentation of the data.</p> </li> <li> <p>Launching the Development Server: Use the specific command to launch the integrated development server of your framework. This will allow you to test your application locally.</p> Bash<pre><code>php floky serve --port 8080\n</code></pre> </li> <li> <p>This command will launch the development server at http://localhost:8080, and you will be able to access your application from your browser.</p> </li> <li> <p>You will see this welcome page :</p> </li> </ol> <p></p>"},{"location":"get-started/configuration/#use-a-local-web-server","title":"Use a Local Web Server","text":"<ul> <li> <p>Launching the Local Web Server: Start your local web server (for example, Apache or Nginx) and configure it to serve your application from the <code>public</code> directory of your project.</p> </li> <li> <p>Access to the Application: Open your web browser and navigate to the appropriate URL for your local web server. You will be able to see your application running.</p> </li> </ul>"},{"location":"get-started/your-first-app/","title":"Your first app","text":""},{"location":"http/controllers/","title":"Controller","text":"<p>Controllers are a fundamental part of the Floky MVC architecture. They handle incoming HTTP requests, interact with models to retrieve or manipulate data, and prepare the data for presentation in views. Controllers provide a layer of abstraction between the routes and the underlying application logic.</p>"},{"location":"http/controllers/#creating-controllers","title":"Creating Controllers","text":"<p>Floky provides a convenient command for quickly creating controllers. This command generates a PHP controller file within the <code>app/Http/Controllers</code> directory.</p> <p>Example:</p> Create a new controller<pre><code>php floky make:controller WelcomeController\n</code></pre> <p>This command will create a WelcomeController.php file inside the <code>app/Http/Controllers</code> directory. The generated file will contain the following boilerplate code:</p> PHP<pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\n\nclass WelcomeController extends Controller\n{\n    // ...\n}\n</code></pre>"},{"location":"http/controllers/#anatomy-of-a-controller","title":"Anatomy of a Controller","text":"<p>A typical Floky controller consists of the following elements:</p> <ul> <li>Namespace: Controllers are typically placed within a namespace that reflects their location within the application. In the example provided, the controller resides in the <code>App\\Http\\Controllers</code> namespace.</li> <li>Inheritance: Floky controllers inherit from the <code>Floky\\Http\\Controllers\\Controller</code> class. This base class provides essential functionalities common to all controllers in your application.</li> <li>Request Handling Methods: Controllers define methods to handle different HTTP request types (GET, POST, PUT, etc.). These methods are decorated with the <code>#[Get]</code>, <code>#[Post]</code>, <code>#[Put]</code>, or <code>#[Delete]</code> attributes from the <code>Floky\\Routing\\Attributes</code> namespace. These attributes specify the HTTP method the method handles and allow you to define the route URL and any middleware to be applied before the method execution.</li> <li>Dependency Injection: Controller methods can accept arguments through constructor injection or method injection. A common approach is to inject the <code>Floky\\Http\\Requests\\Request</code> object to access request data.</li> <li>Model Interaction: Controllers often interact with models to retrieve or manipulate data. Models represent the data layer of your application and encapsulate the business logic.</li> <li>View Rendering: Once the controller has processed the request and prepared the data, it returns a view. The view typically represents the user interface (UI) component responsible for presenting the data to the user. The controller uses the <code>view</code> function provided by Floky to render the desired view and pass any necessary data to it.</li> </ul>"},{"location":"http/controllers/#example-controller","title":"Example Controller","text":"PHP<pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Floky\\Http\\Requests\\Request;\nuse Floky\\Routing\\Attributes\\Get;\n\nclass WelcomeController extends Controller\n{\n\n    #[Get(url: '/welcome', name: 'welcome')]\n    public function index(Request $request) {\n\n        // Simulate some data fetching\n        $data = ['message' =&gt; 'Welcome to Floky!'];\n\n        return view('welcome', $data);\n    }\n}\n</code></pre> <p>In this example, the <code>WelcomeController</code> has an <code>index</code> method decorated with the <code>#[Get]</code> attribute. This method handles GET requests to the <code>/welcome</code> route. The <code>middlewares</code> option specifies that the <code>first</code> middleware should be executed before the controller method. The <code>index</code> method receives a <code>Request</code> object as an argument, allowing it to access request data. Here, the controller simulates fetching some data and then returns the <code>welcome</code> view, passing the <code>$data</code> array containing the welcome message.</p>"},{"location":"http/controllers/#key-points","title":"Key Points","text":"<ul> <li>Controllers are responsible for handling HTTP requests, interacting with models, and preparing data for views.</li> <li>Floky controllers inherit from the <code>Floky\\Http\\Controllers\\Controller</code> class.</li> <li>Request handling methods are decorated with routing attributes to define the HTTP method and route URL.</li> <li>Controllers can leverage dependency injection to access request data and other dependencies.</li> <li>Controllers interact with models to manage application data.</li> <li>Controllers return views to render the UI based on processed data.</li> </ul>"},{"location":"http/custom_request/","title":"Custom Request","text":""},{"location":"http/middleware/","title":"Middleware","text":""},{"location":"http/requests/","title":"The Request Object","text":"<p>The <code>Request</code> object plays a crucial role in Floky applications, providing access to information about the incoming HTTP request. You can inject the <code>Request</code> object into controller methods to retrieve user input, headers, and other request data.  </p>"},{"location":"http/requests/#request-injection","title":"Request Injection","text":"<p>Floky controllers can receive the <code>Request</code> object as an argument in their methods. This allows you to access various request details within your controller logic.</p> <p>Here's an example:</p> PHP<pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nclass WelcomeController extends Controller\n{\n\n    #[Get(url: '/welcome', name: 'welcome')]\n    public function index(Request $request) {\n\n        $name = $request-&gt;get('name'); // Accessing a GET parameter\n        $message = $request-&gt;all();   // Getting all request data\n\n        // ...\n    }\n}\n</code></pre>"},{"location":"http/requests/#request-methods","title":"Request Methods","text":"<p>The <code>Request</code> object provides several methods to access different aspects of the HTTP request:</p> <ul> <li><code>input(string $key, $default = null)</code>: Retrieves a specific value from the request body (either GET or POST data). If the key doesn't exist, it returns the default value.</li> <li><code>get(string $key = null, $default = null)</code>: Retrieves a value from the GET request data. If no key is provided, it returns the entire GET data array.</li> <li><code>post(string $key = null, $default = null)</code>: Retrieves a value from the POST request data. If no key is provided, it returns the entire POST data array.</li> <li><code>only(array $keys)</code>: Returns a subset of the request data containing only the specified keys.</li> <li><code>all()</code>: Returns an array containing all request data merged from GET, POST, and other sources.</li> <li><code>validator(array $rules, array $messages = [])</code>: Creates a validator instance using the BlakvGhost PHPValidator library to validate request data against defined rules. You can specify custom error messages as well.</li> <li><code>validate(array $rules, array $messages = [])</code>: Validates request data against defined rules and throws an exception if validation fails. Alternatively, consider using the <code>back</code> method for redirecting with errors.</li> <li><code>back(mixed $data = [])</code>: Redirects the user back to the previous page (using the <code>Referer</code> header) and stores the provided data in the session for displaying errors or other information.</li> <li><code>getUri()</code>: Returns the current request URI.</li> <li><code>getReferer()</code>: Returns the URL from which the user originated the request (based on the <code>Referer</code> header).</li> <li><code>getUrl()</code>: Alias for <code>getUri()</code>.</li> <li><code>getMethod()</code>: Returns the HTTP method used for the request (GET, POST, PUT, etc.).</li> <li><code>isMethod(string $method)</code>: Checks if the current request method matches the provided method.</li> <li><code>isGet()</code>, <code>isPost()</code>, <code>isPut()</code>, etc.: Convenient methods to check if the current request uses the specific HTTP method.</li> <li><code>header()</code>: Returns a <code>Header</code> object that provides access to request headers.</li> </ul>"},{"location":"http/requests/#accessing-request-headers-in-floky","title":"Accessing Request Headers in Floky","text":"<p>The <code>Header</code> class within Floky's <code>Request</code> component provides functionalities to access and manipulate HTTP headers sent by the client in the request : </p> <ul> <li><code>get(string $headerName)</code>: Retrieves the value of a specific header by name. The header name is converted to uppercase and underscores are replaced with hyphens for compatibility with the server variable format (e.g., <code>Content-Type</code> becomes <code>HTTP_CONTENT_TYPE</code>). This method returns the sanitized value of the header or <code>null</code> if it doesn't exist.</li> <li><code>getAll()</code>: Returns an associative array containing all request headers. The header names are converted to a more readable format (e.g., <code>Content-Type</code> becomes <code>contentType</code>). The values are also sanitized before being returned.</li> </ul> <p>Common Header Checks:</p> <ul> <li><code>acceptJson()</code>: Checks if the request accepts JSON content type (<code>application/json</code>) by examining the <code>Accept</code> header.</li> <li><code>isAjax()</code>: Determines if the request is an AJAX request by checking the presence and value of the <code>X-Requested-With</code> header (<code>XMLHttpRequest</code>).</li> </ul> <p>Setting Headers:</p> <ul> <li><code>set(string $headerName, string $headerValue)</code>: Sets a new HTTP header in the response. This method allows you to define custom headers to be sent back to the client.</li> </ul> <p>Additional Information:</p> <ul> <li><code>isSecure()</code>: Checks if the current request is using a secure HTTPS connection.</li> <li><code>getUserAgent()</code>: Returns the user agent string sent by the client's browser.</li> <li><code>getReferer()</code>: Retrieves the referring URL from the <code>Referer</code> header if present.</li> <li><code>getClientIp()</code>: Returns the client's IP address based on the <code>REMOTE_ADDR</code> server variable.</li> <li><code>getBearer()</code>: Extracts the bearer token from the <code>Authorization</code> header if the request uses Bearer token authentication. It checks for a prefix of <code>\"Bearer \"</code> and returns the remaining string as the token.</li> </ul>"},{"location":"http/requests/#additional-features","title":"Additional Features","text":"<p>File Uploads</p> <p>The <code>Files</code> trait within Floky's <code>Request</code> component provides functionalities to handle file uploads submitted through forms. It's important to note that this trait is used within the <code>Request</code> object, not as a standalone class.</p> <p>Checking for Uploaded Files:</p> <ul> <li><code>hasFile(string $inputName)</code>: This method checks if a specific file input named <code>$inputName</code> exists in the uploaded files array (<code>$_FILES</code>). It returns <code>true</code> if the file was uploaded and <code>false</code> otherwise.</li> </ul> <p>Accessing Uploaded File Details:</p> <ul> <li><code>getFile(string $inputName)</code>: If a file with the given <code>$inputName</code> was uploaded, this method retrieves the corresponding information from the <code>$_FILES</code> array. It returns an associative array containing details about the uploaded file, such as:<ul> <li><code>name</code>: The original filename of the uploaded file.</li> <li><code>type</code>: The MIME type of the uploaded file.</li> <li><code>tmp_name</code>: The temporary filename of the uploaded file on the server.</li> <li><code>error</code>: An error code indicating any issues during the upload process (refer to PHP documentation for specific error codes).</li> <li><code>size</code>: The size of the uploaded file in bytes.</li> </ul> </li> </ul> <p>Moving Uploaded Files:</p> <ul> <li><code>moveUploadedFile(string $inputName, string $destination)</code>: This method attempts to move the uploaded file identified by <code>$inputName</code> to a specified <code>$destination</code> path. It performs the following actions:<ul> <li>Checks if a file with the provided <code>$inputName</code> exists using <code>hasFile</code>.</li> <li>Verifies if the upload was successful by checking the <code>error</code> code in the file information (should be <code>UPLOAD_ERR_OK</code>).</li> <li>Appends the original filename to the provided <code>$destination</code> path to avoid naming conflicts.</li> <li>Uses the <code>move_uploaded_file</code> PHP function to move the temporary file to the specified destination.</li> <li>If the move operation is successful, it returns the complete destination path where the file is now stored.</li> <li>If any errors occur during the process, it returns <code>null</code>.</li> </ul> </li> </ul>"},{"location":"http/requests/#conclusion","title":"Conclusion","text":"<p>The <code>Request</code> object is an essential tool for handling user interactions within your Floky applications. By leveraging its methods, you can effectively retrieve request data, validate user input, and implement various request-related functionalities.</p>"},{"location":"http/resources/","title":"Resources","text":""},{"location":"http/response/","title":"Response","text":"<p>The <code>Response</code> class empowers you to construct varied responses to deliver to the user's browser in your Floky applications. It offers convenient methods to handle various response types effectively.</p>"},{"location":"http/response/#key-methods","title":"Key Methods","text":"<ul> <li> <p><code>json(array $data = [])</code>:</p> <ul> <li>Sets the response content type to <code>application/json</code>.</li> <li>Encodes the provided data as a JSON string.</li> <li>Sends the JSON response to the browser.</li> <li>Frequently employed for API endpoints.</li> </ul> </li> <li> <p><code>html(string $content, int $statusCode = 200)</code>:</p> <ul> <li>Sets the HTTP status code (defaulting to 200).</li> <li>Outputs the specified HTML content directly to the browser.</li> <li>Ideal for rendering views and static HTML responses.</li> </ul> </li> <li> <p><code>redirect(string $url, int $statusCode = 302)</code>:</p> <ul> <li>Sets a redirect header with the given URL.</li> <li>Uses a default status code of 302 (temporary redirect).</li> <li>Redirects the user's browser to the specified URL.</li> </ul> </li> <li> <p><code>text(string $text, int $statusCode = 200)</code>:</p> <ul> <li>Sets the content type to <code>text/plain</code>.</li> <li>Sets a custom HTTP status code (defaulting to 200).</li> <li>Outputs plain text content to the browser.</li> </ul> </li> </ul> <p>Example Usage:</p> PHP<pre><code>&lt;?php\n\n// Returning a JSON response with user data\nreturn Response::json(['name' =&gt; 'John Doe', 'email' =&gt; 'johndoe@example.com']);\n\n// Rendering a view and sending an HTML response\n$content = view('welcome', ['name' =&gt; $user-&gt;name]);\nreturn Response::html($content);\n\n// Redirecting to the home page\nreturn Response::redirect('/');\n</code></pre>"},{"location":"http/response/#using-response-helper","title":"Using <code>response()</code> Helper","text":"<p>This helper function provides an instance of the currently used <code>Response</code> object. This allows you to chain method calls on the response object, leading to more concise and readable code.</p> <p>Example Usage:</p> PHP<pre><code>&lt;?php\n\n// Returning a JSON response with user data (equivalent to Response::json($data))\nreturn response()-&gt;json($data);\n\n// Chaining methods for a more complex response\nreturn response()-&gt;json($data)-&gt;setStatusCode(401); // Set JSON data and status code\n</code></pre>"},{"location":"http/response/#benefits-of-the-helper","title":"Benefits of the Helper","text":"<ul> <li>Improved Code Readability: Chaining methods makes the code flow clearer and easier to understand.</li> <li>Reduced Repetition: Eliminates the need to repeatedly call <code>response()</code> before each method.</li> <li>Simplified Complex Responses: Facilitates building more intricate responses by chaining multiple methods.</li> </ul>"},{"location":"http/response/#in-conclusion","title":"In Conclusion","text":"<p>The <code>Response</code> class simplifies response handling in Floky, enabling you to generate diverse response types with ease. It proves instrumental in crafting informative and engaging user experiences within your web applications. The <code>response()</code> helper adds another layer of convenience to response creation in Floky. By leveraging this helper, you can streamline your code, enhance readability, and craft effective user interactions within your applications.</p>"},{"location":"http/routing/","title":"Routing","text":""},{"location":"http/routing/#routing-in-floky","title":"Routing in Floky","text":"<p>Routing plays a crucial role in any web application, defining how URLs map to specific controller actions. Floky offers a flexible and intuitive routing system that allows you to define routes in two ways.</p>"},{"location":"http/routing/#using-routing-attributes","title":"Using Routing Attributes","text":"<p>You can decorate controller methods with routing attributes to define routes and their corresponding HTTP methods. Floky provides the following routing attributes:</p> <ul> <li><code>#[Get(url: '/path', name: 'routeName', middlewares: [])]</code></li> <li><code>#[Post(url: '/path', name: 'routeName', middlewares: [])]</code></li> <li><code>#[Put(url: '/path', name: 'routeName', middlewares: [])]</code></li> <li><code>#[Patch(url: '/path', name: 'routeName', middlewares: [])]</code></li> <li><code>#[Delete(url: '/path', name: 'routeName', middlewares: [])]</code></li> <li><code>#[MatchWith(['GET', 'POST'], url: '/path', name: 'routeName', middlewares: [])]</code></li> </ul> <p>Example :</p> PHP<pre><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Floky\\Http\\Requests\\Request;\nuse Floky\\Routing\\Attributes\\Get;\n\nclass WelcomeController extends Controller\n{\n\n    #[Get(url: '/welcome', name: 'welcome')]\n    public function index(Request $request) {\n\n        return view('welcome');\n    }\n}\n</code></pre> <p>In this example, the <code>WelcomeController</code> has an <code>index</code> method decorated with the <code>#[Get]</code> attribute. This method handles GET requests to the <code>/welcome</code> URL. The <code>middlewares</code> option specifies that the <code>first</code> middleware should be executed before the controller method.</p>"},{"location":"http/routing/#declaring-routes-in-route-files","title":"Declaring Routes in Route Files","text":"<p>You can also define routes in the <code>web.php</code> and <code>api.php</code> files located in the <code>routes</code> directory. These files use the Laravel Route facade to define routes.</p> <p>Example:</p> PHP<pre><code>&lt;?php\n\nRoute::get('/', function (Request $request) {\n\n    return view('welcome');\n\n});\n</code></pre> <p>This route defines a GET route to the <code>/</code> URL that renders the <code>welcome</code> view. The <code>middleware</code> method is used to assign the <code>first</code> middleware to this route.</p>"},{"location":"http/routing/#benefits-of-routing-attributes","title":"Benefits of Routing Attributes","text":"<ul> <li>Improved readability: Decorating controller methods with attributes makes your code more readable and easier to understand.</li> <li>Reduced boilerplate: You can avoid defining routes in separate files, reducing boilerplate code.</li> <li>Closer association: Routing logic is closely associated with the controller methods it handles.</li> </ul>"},{"location":"http/routing/#using-route-files","title":"Using Route Files","text":"<p>While routing attributes offer a concise and modern approach, defining routes in separate files can be beneficial in certain situations:</p> <ul> <li>Large applications: For large applications with many routes, organizing routes in separate files can improve readability and maintainability.</li> <li>Separation of concerns: It allows you to separate routing logic from controller logic, promoting cleaner code organization.</li> </ul>"},{"location":"http/routing/#conclusion","title":"Conclusion","text":"<p>Floky's routing system provides flexibility and convenience. You can choose the approach that best suits your application's needs and preferences. Consider using routing attributes for smaller applications and simpler routing logic, while larger applications may benefit from defining routes in separate files.</p>"},{"location":"http/views/","title":"View","text":""},{"location":"others/collections/","title":"Collections","text":""},{"location":"others/contributing/","title":"Contributing","text":"<p>We appreciate your interest in contributing to Floky! This page outlines the guidelines for contributing code, documentation, and other improvements to the project.</p>"},{"location":"others/contributing/#how-to-contribute","title":"How to Contribute","text":"<ul> <li>Issues: Report bugs or request features by creating issues on the Floky GitHub repository: https://github.com/v1p3r75/Floky/issues. </li> <li>Pull Requests: Fork the Floky repository, make your changes, and submit a pull request for review. Ensure your pull request adheres to the coding style and includes clear documentation for any new features.</li> </ul> <p>Coding Standards:</p> <ul> <li>Follow PSR-2 coding standards for consistent and readable code.</li> <li>Use meaningful variable and function names.</li> <li>Add comments to explain complex logic or non-obvious code sections.</li> </ul> <p>Documentation:</p> <ul> <li>Improve existing documentation by fixing errors or adding clarity.</li> <li>Contribute new documentation for features or functionalities you introduce.</li> <li>Use clear and concise language with proper grammar.</li> </ul>"},{"location":"others/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the Floky Repository: Create a fork of the Floky repository on GitHub.</li> <li>Clone your Fork: Clone your forked repository to your local machine.</li> <li>Create a Branch: Create a new branch for your specific contribution.</li> <li>Make Changes: Make your changes to the code or documentation.</li> <li>Commit Changes: Commit your changes with clear commit messages.</li> <li>Push Changes: Push your changes to your forked repository on GitHub.</li> <li>Create a Pull Request: Create a pull request from your branch to the main Floky repository.</li> </ol>"},{"location":"others/contributing/#additional-tips","title":"Additional Tips","text":"<ul> <li>Unit Tests: Consider adding unit tests for any new code you introduce.</li> <li>Code Reviews: Participate in code reviews for other pull requests to ensure overall code quality.</li> <li>Stay Updated: Follow the Floky project for updates and announcements.</li> </ul>"},{"location":"others/contributing/#we-welcome-your-contributions","title":"We welcome your contributions!","text":"<p>By following these guidelines, you can help us make Floky a better and more valuable project for everyone. If you have any questions or need assistance, feel free to reach out to the project maintainers on the Floky GitHub repository.</p>"},{"location":"others/exceptions/","title":"Exceptions","text":""},{"location":"others/facades/","title":"Facades","text":""},{"location":"others/helpers/","title":"Helpers","text":""},{"location":"others/services/","title":"Services","text":""}]}